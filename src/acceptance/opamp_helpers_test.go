package acceptance_test

import (
	"fmt"
	"os/exec"
	"time"

	"github.com/onsi/gomega/gbytes"
	"github.com/onsi/gomega/gexec"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

// OpAMPTestHelpers provides utility functions for OpAMP acceptance tests

// CheckOpAMPSupervisorRunning verifies that the OpAMP supervisor process is running
func CheckOpAMPSupervisorRunning(vmName string) *gbytes.Buffer {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo ps aux | grep opampsupervisor")
	session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
	Expect(err).ShouldNot(HaveOccurred())
	return session.Wait(30 * time.Second).Out
}

// CheckOpAMPSupervisorNotRunning verifies that the OpAMP supervisor process is not running
func CheckOpAMPSupervisorNotRunning(vmName string) error {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo ps aux | grep opampsupervisor | grep -v grep && exit 1 || exit 0")
	cmd.Stdout = GinkgoWriter
	cmd.Stderr = GinkgoWriter
	return cmd.Run()
}

// GetCollectorLogs retrieves collector logs from the specified VM
func GetCollectorLogs(vmName string, lines int) *gbytes.Buffer {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", fmt.Sprintf("sudo journalctl -u vcap.otel-collector --no-pager -n %d", lines))
	session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
	Expect(err).ShouldNot(HaveOccurred())
	return session.Wait(60 * time.Second).Out
}

// GetOpAMPSupervisorLogs retrieves OpAMP supervisor logs from the collector job (unified logs)
func GetOpAMPSupervisorLogs(vmName string, lines int) *gbytes.Buffer {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", fmt.Sprintf("sudo journalctl -u vcap.otel-collector --no-pager -n %d | grep -i supervisor", lines))
	session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
	Expect(err).ShouldNot(HaveOccurred())
	return session.Wait(60 * time.Second).Out
}

// GetOpAMPSupervisorConfig retrieves the OpAMP supervisor configuration from the specified VM (generated by wrapper)
func GetOpAMPSupervisorConfig(vmName string) *gbytes.Buffer {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo cat /var/vcap/jobs/opamp-supervisor/config/opamp-supervisor.yml")
	session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
	Expect(err).ShouldNot(HaveOccurred())
	return session.Wait(30 * time.Second).Out
}

// CheckFileExists verifies that a file exists on the specified VM
func CheckFileExists(vmName, filePath string) error {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", fmt.Sprintf("test -f %s", filePath))
	cmd.Stdout = GinkgoWriter
	cmd.Stderr = GinkgoWriter
	return cmd.Run()
}

// CheckDirectoryExists verifies that a directory exists on the specified VM
func CheckDirectoryExists(vmName, dirPath string) error {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", fmt.Sprintf("test -d %s", dirPath))
	cmd.Stdout = GinkgoWriter
	cmd.Stderr = GinkgoWriter
	return cmd.Run()
}

// WaitForOpAMPSupervisorStartup waits for OpAMP supervisor to start up (via wrapper script)
func WaitForOpAMPSupervisorStartup(vmName string, timeout time.Duration) {
	Eventually(func(g Gomega) *gbytes.Buffer {
		return GetCollectorLogs(vmName, 200)
	}, timeout).Should(gbytes.Say("Starting dual-process mode|Starting OpAMP Supervisor"), "OpAMP supervisor should start up via wrapper script")
}

// ValidateOpAMPSupervisorConfiguration validates that OpAMP supervisor configuration is properly formatted
func ValidateOpAMPSupervisorConfiguration(vmName string) {
	config := GetOpAMPSupervisorConfig(vmName)

	// Check for required supervisor configuration sections
	Expect(config).To(gbytes.Say("server:"), "Supervisor server configuration should be present")
	Expect(config).To(gbytes.Say("capabilities:"), "Supervisor capabilities should be configured")
	Expect(config).To(gbytes.Say("storage:"), "Supervisor storage configuration should be present")
}

// CheckWrapperScriptUsage verifies that the wrapper script is being used for process management
func CheckWrapperScriptUsage(vmName string) error {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo cat /var/vcap/jobs/otel-collector/bin/bpm.yml | grep -q 'otel-wrapper.sh'")
	cmd.Stdout = GinkgoWriter
	cmd.Stderr = GinkgoWriter
	return cmd.Run()
}

// ValidateDualProcessMode validates that both collector and supervisor are running when OpAMP is enabled
func ValidateDualProcessMode(vmName string) {
	Eventually(func(g Gomega) *gbytes.Buffer {
		cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo ps aux | grep -E '(otelcol-cf|opampsupervisor)' | grep -v grep")
		session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
		Expect(err).ShouldNot(HaveOccurred())
		return session.Wait(30 * time.Second).Out
	}, 60*time.Second).Should(gbytes.Say("otelcol-cf"), "Collector process should be running")

	Eventually(func(g Gomega) *gbytes.Buffer {
		cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo ps aux | grep -E '(otelcol-cf|opampsupervisor)' | grep -v grep")
		session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
		Expect(err).ShouldNot(HaveOccurred())
		return session.Wait(30 * time.Second).Out
	}, 60*time.Second).Should(gbytes.Say("opampsupervisor"), "Supervisor process should be running")
}

// ValidateSingleProcessMode validates that only collector is running when OpAMP is disabled
func ValidateSingleProcessMode(vmName string) {
	Eventually(func(g Gomega) *gbytes.Buffer {
		cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo ps aux | grep otelcol-cf | grep -v grep")
		session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
		Expect(err).ShouldNot(HaveOccurred())
		return session.Wait(30 * time.Second).Out
	}, 60*time.Second).Should(gbytes.Say("otelcol-cf"), "Collector process should be running")

	// Verify supervisor is NOT running
	Eventually(func() error {
		cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo ps aux | grep opampsupervisor | grep -v grep && exit 1 || exit 0")
		cmd.Stdout = GinkgoWriter
		cmd.Stderr = GinkgoWriter
		return cmd.Run()
	}, 30*time.Second, 5*time.Second).Should(Succeed(), "OpAMP supervisor should not be running when disabled")
}
