package acceptance_test

import (
	"fmt"
	"os/exec"
	"time"

	"github.com/onsi/gomega/gbytes"
	"github.com/onsi/gomega/gexec"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

// OpAMPTestHelpers provides utility functions for OpAMP acceptance tests

// CheckOpAMPExtensionEnabled verifies that OpAMP extension is enabled in the collector configuration
func CheckOpAMPExtensionEnabled(vmName string) error {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo cat /var/vcap/jobs/otel-collector/config/config.yml | grep -A 10 'extensions:' | grep -q 'opamp:'")
	cmd.Stdout = GinkgoWriter
	cmd.Stderr = GinkgoWriter
	return cmd.Run()
}

// CheckOpAMPExtensionDisabled verifies that OpAMP extension is not present in the collector configuration
func CheckOpAMPExtensionDisabled(vmName string) error {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo cat /var/vcap/jobs/otel-collector/config/config.yml | grep -v '^#' | grep -q 'opamp:' && exit 1 || exit 0")
	cmd.Stdout = GinkgoWriter
	cmd.Stderr = GinkgoWriter
	return cmd.Run()
}

// CheckHealthEndpoint verifies that the health check endpoint is responding
func CheckHealthEndpoint(vmName string, port int) error {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", fmt.Sprintf("curl -f -s http://localhost:%d/", port))
	cmd.Stdout = GinkgoWriter
	cmd.Stderr = GinkgoWriter
	return cmd.Run()
}

// CheckOpAMPSupervisorRunning verifies that the OpAMP supervisor process is running
func CheckOpAMPSupervisorRunning(vmName string) *gbytes.Buffer {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo ps aux | grep opampsupervisor")
	session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
	Expect(err).ShouldNot(HaveOccurred())
	return session.Wait(30 * time.Second).Out
}

// CheckOpAMPSupervisorNotRunning verifies that the OpAMP supervisor process is not running
func CheckOpAMPSupervisorNotRunning(vmName string) error {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo ps aux | grep opampsupervisor | grep -v grep && exit 1 || exit 0")
	cmd.Stdout = GinkgoWriter
	cmd.Stderr = GinkgoWriter
	return cmd.Run()
}

// GetCollectorLogs retrieves collector logs from the specified VM
func GetCollectorLogs(vmName string, lines int) *gbytes.Buffer {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", fmt.Sprintf("sudo journalctl -u vcap.otel-collector --no-pager -n %d", lines))
	session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
	Expect(err).ShouldNot(HaveOccurred())
	return session.Wait(60 * time.Second).Out
}

// GetOpAMPSupervisorLogs retrieves OpAMP supervisor logs from the collector job (unified logs)
func GetOpAMPSupervisorLogs(vmName string, lines int) *gbytes.Buffer {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", fmt.Sprintf("sudo journalctl -u vcap.otel-collector --no-pager -n %d | grep -i supervisor", lines))
	session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
	Expect(err).ShouldNot(HaveOccurred())
	return session.Wait(60 * time.Second).Out
}

// GetCollectorConfig retrieves the collector configuration from the specified VM
func GetCollectorConfig(vmName string) *gbytes.Buffer {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo cat /var/vcap/jobs/otel-collector/config/config.yml")
	session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
	Expect(err).ShouldNot(HaveOccurred())
	return session.Wait(30 * time.Second).Out
}

// GetOpAMPSupervisorConfig retrieves the OpAMP supervisor configuration from the specified VM (generated by wrapper)
func GetOpAMPSupervisorConfig(vmName string) *gbytes.Buffer {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo cat /var/vcap/jobs/otel-collector/config/opamp-supervisor.yml")
	session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
	Expect(err).ShouldNot(HaveOccurred())
	return session.Wait(30 * time.Second).Out
}

// CheckFileExists verifies that a file exists on the specified VM
func CheckFileExists(vmName, filePath string) error {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", fmt.Sprintf("test -f %s", filePath))
	cmd.Stdout = GinkgoWriter
	cmd.Stderr = GinkgoWriter
	return cmd.Run()
}

// CheckDirectoryExists verifies that a directory exists on the specified VM
func CheckDirectoryExists(vmName, dirPath string) error {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", fmt.Sprintf("test -d %s", dirPath))
	cmd.Stdout = GinkgoWriter
	cmd.Stderr = GinkgoWriter
	return cmd.Run()
}

// GetMetrics retrieves metrics from the collector's metrics endpoint
func GetMetrics(vmName string, port int) *gbytes.Buffer {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", fmt.Sprintf("curl -s http://localhost:%d/metrics", port))
	session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
	Expect(err).ShouldNot(HaveOccurred())
	return session.Wait(30 * time.Second).Out
}

// CheckWindowsOpAMPConfig verifies OpAMP configuration on Windows VMs
func CheckWindowsOpAMPConfig(vmName string) *gbytes.Buffer {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", "powershell -Command \"Get-Content C:\\var\\vcap\\jobs\\otel-collector\\config\\config.yml | Select-String 'opamp'\"")
	session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
	Expect(err).ShouldNot(HaveOccurred())
	return session.Wait(60 * time.Second).Out
}

// CheckWindowsHealthEndpoint verifies health endpoint on Windows VMs
func CheckWindowsHealthEndpoint(vmName string, port int) error {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", fmt.Sprintf("powershell -Command \"Invoke-WebRequest -Uri http://localhost:%d/ -UseBasicParsing\"", port))
	cmd.Stdout = GinkgoWriter
	cmd.Stderr = GinkgoWriter
	return cmd.Run()
}

// WaitForOpAMPConnection waits for OpAMP connection to be established
func WaitForOpAMPConnection(vmName string, timeout time.Duration) {
	Eventually(func(g Gomega) *gbytes.Buffer {
		return GetCollectorLogs(vmName, 200)
	}, timeout).Should(gbytes.Say("opamp.*connected|opamp.*established"), "OpAMP connection should be established")
}

// WaitForOpAMPSupervisorStartup waits for OpAMP supervisor to start up (via wrapper script)
func WaitForOpAMPSupervisorStartup(vmName string, timeout time.Duration) {
	Eventually(func(g Gomega) *gbytes.Buffer {
		return GetCollectorLogs(vmName, 200)
	}, timeout).Should(gbytes.Say("Starting dual-process mode|Starting OpAMP Supervisor"), "OpAMP supervisor should start up via wrapper script")
}

// ValidateOpAMPConfiguration validates that OpAMP configuration is properly formatted
func ValidateOpAMPConfiguration(vmName string) {
	config := GetCollectorConfig(vmName)

	// Check for required OpAMP configuration sections
	Expect(config).To(gbytes.Say("opamp:"), "OpAMP extension should be configured")
	Expect(config).To(gbytes.Say("server:"), "OpAMP server configuration should be present")
	Expect(config).To(gbytes.Say("endpoint:"), "OpAMP endpoint should be configured")
	Expect(config).To(gbytes.Say("agent_description:"), "OpAMP agent description should be present")
}

// ValidateOpAMPSupervisorConfiguration validates that OpAMP supervisor configuration is properly formatted
func ValidateOpAMPSupervisorConfiguration(vmName string) {
	config := GetOpAMPSupervisorConfig(vmName)

	// Check for required supervisor configuration sections
	Expect(config).To(gbytes.Say("server:"), "Supervisor server configuration should be present")
	Expect(config).To(gbytes.Say("capabilities:"), "Supervisor capabilities should be configured")
	Expect(config).To(gbytes.Say("storage:"), "Supervisor storage configuration should be present")
}

// CheckWrapperScriptUsage verifies that the wrapper script is being used for process management
func CheckWrapperScriptUsage(vmName string) error {
	cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo cat /var/vcap/jobs/otel-collector/bin/bpm.yml | grep -q 'otel-wrapper.sh'")
	cmd.Stdout = GinkgoWriter
	cmd.Stderr = GinkgoWriter
	return cmd.Run()
}

// ValidateDualProcessMode validates that both collector and supervisor are running when OpAMP is enabled
func ValidateDualProcessMode(vmName string) {
	Eventually(func(g Gomega) *gbytes.Buffer {
		cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo ps aux | grep -E '(otelcol-cf|opampsupervisor)' | grep -v grep")
		session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
		Expect(err).ShouldNot(HaveOccurred())
		return session.Wait(30 * time.Second).Out
	}, 60*time.Second).Should(gbytes.Say("otelcol-cf"), "Collector process should be running")

	Eventually(func(g Gomega) *gbytes.Buffer {
		cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo ps aux | grep -E '(otelcol-cf|opampsupervisor)' | grep -v grep")
		session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
		Expect(err).ShouldNot(HaveOccurred())
		return session.Wait(30 * time.Second).Out
	}, 60*time.Second).Should(gbytes.Say("opampsupervisor"), "Supervisor process should be running")
}

// ValidateSingleProcessMode validates that only collector is running when OpAMP is disabled
func ValidateSingleProcessMode(vmName string) {
	Eventually(func(g Gomega) *gbytes.Buffer {
		cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo ps aux | grep otelcol-cf | grep -v grep")
		session, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
		Expect(err).ShouldNot(HaveOccurred())
		return session.Wait(30 * time.Second).Out
	}, 60*time.Second).Should(gbytes.Say("otelcol-cf"), "Collector process should be running")

	// Verify supervisor is NOT running
	Eventually(func() error {
		cmd := exec.Command("bosh", "ssh", vmName, "-c", "sudo ps aux | grep opampsupervisor | grep -v grep && exit 1 || exit 0")
		cmd.Stdout = GinkgoWriter
		cmd.Stderr = GinkgoWriter
		return cmd.Run()
	}, 30*time.Second, 5*time.Second).Should(Succeed(), "OpAMP supervisor should not be running when disabled")
}
